// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: descriptor.proto

package descriptorpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on FileDescriptorSet with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FileDescriptorSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileDescriptorSet with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FileDescriptorSetMultiError, or nil if none found.
func (m *FileDescriptorSet) ValidateAll() error {
	return m.validate(true)
}

func (m *FileDescriptorSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFile() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileDescriptorSetValidationError{
						field:  fmt.Sprintf("File[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileDescriptorSetValidationError{
						field:  fmt.Sprintf("File[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileDescriptorSetValidationError{
					field:  fmt.Sprintf("File[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FileDescriptorSetMultiError(errors)
	}

	return nil
}

// FileDescriptorSetMultiError is an error wrapping multiple validation errors
// returned by FileDescriptorSet.ValidateAll() if the designated constraints
// aren't met.
type FileDescriptorSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileDescriptorSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileDescriptorSetMultiError) AllErrors() []error { return m }

// FileDescriptorSetValidationError is the validation error returned by
// FileDescriptorSet.Validate if the designated constraints aren't met.
type FileDescriptorSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileDescriptorSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileDescriptorSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileDescriptorSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileDescriptorSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileDescriptorSetValidationError) ErrorName() string {
	return "FileDescriptorSetValidationError"
}

// Error satisfies the builtin error interface
func (e FileDescriptorSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileDescriptorSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileDescriptorSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileDescriptorSetValidationError{}

// Validate checks the field values on FileDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FileDescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FileDescriptorProtoMultiError, or nil if none found.
func (m *FileDescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *FileDescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Package

	for idx, item := range m.GetMessageType() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileDescriptorProtoValidationError{
						field:  fmt.Sprintf("MessageType[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileDescriptorProtoValidationError{
						field:  fmt.Sprintf("MessageType[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileDescriptorProtoValidationError{
					field:  fmt.Sprintf("MessageType[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEnumType() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileDescriptorProtoValidationError{
						field:  fmt.Sprintf("EnumType[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileDescriptorProtoValidationError{
						field:  fmt.Sprintf("EnumType[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileDescriptorProtoValidationError{
					field:  fmt.Sprintf("EnumType[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetService() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileDescriptorProtoValidationError{
						field:  fmt.Sprintf("Service[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileDescriptorProtoValidationError{
						field:  fmt.Sprintf("Service[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileDescriptorProtoValidationError{
					field:  fmt.Sprintf("Service[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileDescriptorProtoValidationError{
						field:  fmt.Sprintf("Extension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileDescriptorProtoValidationError{
						field:  fmt.Sprintf("Extension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileDescriptorProtoValidationError{
					field:  fmt.Sprintf("Extension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileDescriptorProtoValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSourceCodeInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileDescriptorProtoValidationError{
					field:  "SourceCodeInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileDescriptorProtoValidationError{
					field:  "SourceCodeInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceCodeInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileDescriptorProtoValidationError{
				field:  "SourceCodeInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Syntax

	if len(errors) > 0 {
		return FileDescriptorProtoMultiError(errors)
	}

	return nil
}

// FileDescriptorProtoMultiError is an error wrapping multiple validation
// errors returned by FileDescriptorProto.ValidateAll() if the designated
// constraints aren't met.
type FileDescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileDescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileDescriptorProtoMultiError) AllErrors() []error { return m }

// FileDescriptorProtoValidationError is the validation error returned by
// FileDescriptorProto.Validate if the designated constraints aren't met.
type FileDescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileDescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileDescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileDescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileDescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileDescriptorProtoValidationError) ErrorName() string {
	return "FileDescriptorProtoValidationError"
}

// Error satisfies the builtin error interface
func (e FileDescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileDescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileDescriptorProtoValidationError{}

// Validate checks the field values on DescriptorProto with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DescriptorProtoMultiError, or nil if none found.
func (m *DescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *DescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetField() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("Field[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("Field[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DescriptorProtoValidationError{
					field:  fmt.Sprintf("Field[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("Extension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("Extension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DescriptorProtoValidationError{
					field:  fmt.Sprintf("Extension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetNestedType() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("NestedType[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("NestedType[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DescriptorProtoValidationError{
					field:  fmt.Sprintf("NestedType[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEnumType() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("EnumType[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("EnumType[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DescriptorProtoValidationError{
					field:  fmt.Sprintf("EnumType[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExtensionRange() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("ExtensionRange[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("ExtensionRange[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DescriptorProtoValidationError{
					field:  fmt.Sprintf("ExtensionRange[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOneofDecl() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("OneofDecl[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("OneofDecl[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DescriptorProtoValidationError{
					field:  fmt.Sprintf("OneofDecl[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DescriptorProtoValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetReservedRange() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("ReservedRange[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DescriptorProtoValidationError{
						field:  fmt.Sprintf("ReservedRange[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DescriptorProtoValidationError{
					field:  fmt.Sprintf("ReservedRange[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DescriptorProtoMultiError(errors)
	}

	return nil
}

// DescriptorProtoMultiError is an error wrapping multiple validation errors
// returned by DescriptorProto.ValidateAll() if the designated constraints
// aren't met.
type DescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescriptorProtoMultiError) AllErrors() []error { return m }

// DescriptorProtoValidationError is the validation error returned by
// DescriptorProto.Validate if the designated constraints aren't met.
type DescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescriptorProtoValidationError) ErrorName() string { return "DescriptorProtoValidationError" }

// Error satisfies the builtin error interface
func (e DescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescriptorProtoValidationError{}

// Validate checks the field values on ExtensionRangeOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExtensionRangeOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtensionRangeOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtensionRangeOptionsMultiError, or nil if none found.
func (m *ExtensionRangeOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtensionRangeOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtensionRangeOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtensionRangeOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtensionRangeOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExtensionRangeOptionsMultiError(errors)
	}

	return nil
}

// ExtensionRangeOptionsMultiError is an error wrapping multiple validation
// errors returned by ExtensionRangeOptions.ValidateAll() if the designated
// constraints aren't met.
type ExtensionRangeOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtensionRangeOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtensionRangeOptionsMultiError) AllErrors() []error { return m }

// ExtensionRangeOptionsValidationError is the validation error returned by
// ExtensionRangeOptions.Validate if the designated constraints aren't met.
type ExtensionRangeOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtensionRangeOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtensionRangeOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtensionRangeOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtensionRangeOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtensionRangeOptionsValidationError) ErrorName() string {
	return "ExtensionRangeOptionsValidationError"
}

// Error satisfies the builtin error interface
func (e ExtensionRangeOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtensionRangeOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtensionRangeOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtensionRangeOptionsValidationError{}

// Validate checks the field values on FieldDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FieldDescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FieldDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FieldDescriptorProtoMultiError, or nil if none found.
func (m *FieldDescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldDescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Number

	// no validation rules for Label

	// no validation rules for Type

	// no validation rules for TypeName

	// no validation rules for Extendee

	// no validation rules for DefaultValue

	// no validation rules for OneofIndex

	// no validation rules for JsonName

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FieldDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FieldDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FieldDescriptorProtoValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Proto3Optional

	if len(errors) > 0 {
		return FieldDescriptorProtoMultiError(errors)
	}

	return nil
}

// FieldDescriptorProtoMultiError is an error wrapping multiple validation
// errors returned by FieldDescriptorProto.ValidateAll() if the designated
// constraints aren't met.
type FieldDescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldDescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldDescriptorProtoMultiError) AllErrors() []error { return m }

// FieldDescriptorProtoValidationError is the validation error returned by
// FieldDescriptorProto.Validate if the designated constraints aren't met.
type FieldDescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldDescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldDescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldDescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldDescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldDescriptorProtoValidationError) ErrorName() string {
	return "FieldDescriptorProtoValidationError"
}

// Error satisfies the builtin error interface
func (e FieldDescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldDescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldDescriptorProtoValidationError{}

// Validate checks the field values on OneofDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OneofDescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OneofDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OneofDescriptorProtoMultiError, or nil if none found.
func (m *OneofDescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *OneofDescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OneofDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OneofDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OneofDescriptorProtoValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OneofDescriptorProtoMultiError(errors)
	}

	return nil
}

// OneofDescriptorProtoMultiError is an error wrapping multiple validation
// errors returned by OneofDescriptorProto.ValidateAll() if the designated
// constraints aren't met.
type OneofDescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OneofDescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OneofDescriptorProtoMultiError) AllErrors() []error { return m }

// OneofDescriptorProtoValidationError is the validation error returned by
// OneofDescriptorProto.Validate if the designated constraints aren't met.
type OneofDescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OneofDescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OneofDescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OneofDescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OneofDescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OneofDescriptorProtoValidationError) ErrorName() string {
	return "OneofDescriptorProtoValidationError"
}

// Error satisfies the builtin error interface
func (e OneofDescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOneofDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OneofDescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OneofDescriptorProtoValidationError{}

// Validate checks the field values on EnumDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnumDescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnumDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnumDescriptorProtoMultiError, or nil if none found.
func (m *EnumDescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *EnumDescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnumDescriptorProtoValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnumDescriptorProtoValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnumDescriptorProtoValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnumDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnumDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnumDescriptorProtoValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetReservedRange() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnumDescriptorProtoValidationError{
						field:  fmt.Sprintf("ReservedRange[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnumDescriptorProtoValidationError{
						field:  fmt.Sprintf("ReservedRange[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnumDescriptorProtoValidationError{
					field:  fmt.Sprintf("ReservedRange[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnumDescriptorProtoMultiError(errors)
	}

	return nil
}

// EnumDescriptorProtoMultiError is an error wrapping multiple validation
// errors returned by EnumDescriptorProto.ValidateAll() if the designated
// constraints aren't met.
type EnumDescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumDescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumDescriptorProtoMultiError) AllErrors() []error { return m }

// EnumDescriptorProtoValidationError is the validation error returned by
// EnumDescriptorProto.Validate if the designated constraints aren't met.
type EnumDescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumDescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumDescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumDescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumDescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumDescriptorProtoValidationError) ErrorName() string {
	return "EnumDescriptorProtoValidationError"
}

// Error satisfies the builtin error interface
func (e EnumDescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumDescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumDescriptorProtoValidationError{}

// Validate checks the field values on EnumValueDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnumValueDescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnumValueDescriptorProto with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnumValueDescriptorProtoMultiError, or nil if none found.
func (m *EnumValueDescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *EnumValueDescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Number

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnumValueDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnumValueDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnumValueDescriptorProtoValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnumValueDescriptorProtoMultiError(errors)
	}

	return nil
}

// EnumValueDescriptorProtoMultiError is an error wrapping multiple validation
// errors returned by EnumValueDescriptorProto.ValidateAll() if the designated
// constraints aren't met.
type EnumValueDescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumValueDescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumValueDescriptorProtoMultiError) AllErrors() []error { return m }

// EnumValueDescriptorProtoValidationError is the validation error returned by
// EnumValueDescriptorProto.Validate if the designated constraints aren't met.
type EnumValueDescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumValueDescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumValueDescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumValueDescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumValueDescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumValueDescriptorProtoValidationError) ErrorName() string {
	return "EnumValueDescriptorProtoValidationError"
}

// Error satisfies the builtin error interface
func (e EnumValueDescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumValueDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumValueDescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumValueDescriptorProtoValidationError{}

// Validate checks the field values on ServiceDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceDescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceDescriptorProtoMultiError, or nil if none found.
func (m *ServiceDescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceDescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetMethod() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceDescriptorProtoValidationError{
						field:  fmt.Sprintf("Method[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceDescriptorProtoValidationError{
						field:  fmt.Sprintf("Method[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceDescriptorProtoValidationError{
					field:  fmt.Sprintf("Method[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceDescriptorProtoValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServiceDescriptorProtoMultiError(errors)
	}

	return nil
}

// ServiceDescriptorProtoMultiError is an error wrapping multiple validation
// errors returned by ServiceDescriptorProto.ValidateAll() if the designated
// constraints aren't met.
type ServiceDescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceDescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceDescriptorProtoMultiError) AllErrors() []error { return m }

// ServiceDescriptorProtoValidationError is the validation error returned by
// ServiceDescriptorProto.Validate if the designated constraints aren't met.
type ServiceDescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceDescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceDescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceDescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceDescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceDescriptorProtoValidationError) ErrorName() string {
	return "ServiceDescriptorProtoValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceDescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceDescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceDescriptorProtoValidationError{}

// Validate checks the field values on MethodDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MethodDescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MethodDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MethodDescriptorProtoMultiError, or nil if none found.
func (m *MethodDescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *MethodDescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for InputType

	// no validation rules for OutputType

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MethodDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MethodDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MethodDescriptorProtoValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ClientStreaming

	// no validation rules for ServerStreaming

	if len(errors) > 0 {
		return MethodDescriptorProtoMultiError(errors)
	}

	return nil
}

// MethodDescriptorProtoMultiError is an error wrapping multiple validation
// errors returned by MethodDescriptorProto.ValidateAll() if the designated
// constraints aren't met.
type MethodDescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MethodDescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MethodDescriptorProtoMultiError) AllErrors() []error { return m }

// MethodDescriptorProtoValidationError is the validation error returned by
// MethodDescriptorProto.Validate if the designated constraints aren't met.
type MethodDescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MethodDescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MethodDescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MethodDescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MethodDescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MethodDescriptorProtoValidationError) ErrorName() string {
	return "MethodDescriptorProtoValidationError"
}

// Error satisfies the builtin error interface
func (e MethodDescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMethodDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MethodDescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MethodDescriptorProtoValidationError{}

// Validate checks the field values on FileOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileOptionsMultiError, or
// nil if none found.
func (m *FileOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *FileOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for JavaPackage

	// no validation rules for JavaOuterClassname

	// no validation rules for JavaMultipleFiles

	// no validation rules for JavaGenerateEqualsAndHash

	// no validation rules for JavaStringCheckUtf8

	// no validation rules for OptimizeFor

	// no validation rules for GoPackage

	// no validation rules for CcGenericServices

	// no validation rules for JavaGenericServices

	// no validation rules for PyGenericServices

	// no validation rules for PhpGenericServices

	// no validation rules for Deprecated

	// no validation rules for CcEnableArenas

	// no validation rules for ObjcClassPrefix

	// no validation rules for CsharpNamespace

	// no validation rules for SwiftPrefix

	// no validation rules for PhpClassPrefix

	// no validation rules for PhpNamespace

	// no validation rules for PhpMetadataNamespace

	// no validation rules for RubyPackage

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FileOptionsMultiError(errors)
	}

	return nil
}

// FileOptionsMultiError is an error wrapping multiple validation errors
// returned by FileOptions.ValidateAll() if the designated constraints aren't met.
type FileOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileOptionsMultiError) AllErrors() []error { return m }

// FileOptionsValidationError is the validation error returned by
// FileOptions.Validate if the designated constraints aren't met.
type FileOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileOptionsValidationError) ErrorName() string { return "FileOptionsValidationError" }

// Error satisfies the builtin error interface
func (e FileOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileOptionsValidationError{}

// Validate checks the field values on MessageOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MessageOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MessageOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MessageOptionsMultiError,
// or nil if none found.
func (m *MessageOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *MessageOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MessageSetWireFormat

	// no validation rules for NoStandardDescriptorAccessor

	// no validation rules for Deprecated

	// no validation rules for MapEntry

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MessageOptionsMultiError(errors)
	}

	return nil
}

// MessageOptionsMultiError is an error wrapping multiple validation errors
// returned by MessageOptions.ValidateAll() if the designated constraints
// aren't met.
type MessageOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessageOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessageOptionsMultiError) AllErrors() []error { return m }

// MessageOptionsValidationError is the validation error returned by
// MessageOptions.Validate if the designated constraints aren't met.
type MessageOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessageOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessageOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessageOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessageOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessageOptionsValidationError) ErrorName() string { return "MessageOptionsValidationError" }

// Error satisfies the builtin error interface
func (e MessageOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessageOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessageOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessageOptionsValidationError{}

// Validate checks the field values on FieldOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FieldOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FieldOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FieldOptionsMultiError, or
// nil if none found.
func (m *FieldOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ctype

	// no validation rules for Packed

	// no validation rules for Jstype

	// no validation rules for Lazy

	// no validation rules for UnverifiedLazy

	// no validation rules for Deprecated

	// no validation rules for Weak

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FieldOptionsMultiError(errors)
	}

	return nil
}

// FieldOptionsMultiError is an error wrapping multiple validation errors
// returned by FieldOptions.ValidateAll() if the designated constraints aren't met.
type FieldOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldOptionsMultiError) AllErrors() []error { return m }

// FieldOptionsValidationError is the validation error returned by
// FieldOptions.Validate if the designated constraints aren't met.
type FieldOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldOptionsValidationError) ErrorName() string { return "FieldOptionsValidationError" }

// Error satisfies the builtin error interface
func (e FieldOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldOptionsValidationError{}

// Validate checks the field values on OneofOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OneofOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OneofOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OneofOptionsMultiError, or
// nil if none found.
func (m *OneofOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *OneofOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OneofOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OneofOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OneofOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OneofOptionsMultiError(errors)
	}

	return nil
}

// OneofOptionsMultiError is an error wrapping multiple validation errors
// returned by OneofOptions.ValidateAll() if the designated constraints aren't met.
type OneofOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OneofOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OneofOptionsMultiError) AllErrors() []error { return m }

// OneofOptionsValidationError is the validation error returned by
// OneofOptions.Validate if the designated constraints aren't met.
type OneofOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OneofOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OneofOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OneofOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OneofOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OneofOptionsValidationError) ErrorName() string { return "OneofOptionsValidationError" }

// Error satisfies the builtin error interface
func (e OneofOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOneofOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OneofOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OneofOptionsValidationError{}

// Validate checks the field values on EnumOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnumOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnumOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnumOptionsMultiError, or
// nil if none found.
func (m *EnumOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *EnumOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AllowAlias

	// no validation rules for Deprecated

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnumOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnumOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnumOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnumOptionsMultiError(errors)
	}

	return nil
}

// EnumOptionsMultiError is an error wrapping multiple validation errors
// returned by EnumOptions.ValidateAll() if the designated constraints aren't met.
type EnumOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumOptionsMultiError) AllErrors() []error { return m }

// EnumOptionsValidationError is the validation error returned by
// EnumOptions.Validate if the designated constraints aren't met.
type EnumOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumOptionsValidationError) ErrorName() string { return "EnumOptionsValidationError" }

// Error satisfies the builtin error interface
func (e EnumOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumOptionsValidationError{}

// Validate checks the field values on EnumValueOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EnumValueOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnumValueOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnumValueOptionsMultiError, or nil if none found.
func (m *EnumValueOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *EnumValueOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deprecated

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnumValueOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnumValueOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnumValueOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnumValueOptionsMultiError(errors)
	}

	return nil
}

// EnumValueOptionsMultiError is an error wrapping multiple validation errors
// returned by EnumValueOptions.ValidateAll() if the designated constraints
// aren't met.
type EnumValueOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumValueOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumValueOptionsMultiError) AllErrors() []error { return m }

// EnumValueOptionsValidationError is the validation error returned by
// EnumValueOptions.Validate if the designated constraints aren't met.
type EnumValueOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumValueOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumValueOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumValueOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumValueOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumValueOptionsValidationError) ErrorName() string { return "EnumValueOptionsValidationError" }

// Error satisfies the builtin error interface
func (e EnumValueOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumValueOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumValueOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumValueOptionsValidationError{}

// Validate checks the field values on ServiceOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceOptionsMultiError,
// or nil if none found.
func (m *ServiceOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deprecated

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceOptionsMultiError(errors)
	}

	return nil
}

// ServiceOptionsMultiError is an error wrapping multiple validation errors
// returned by ServiceOptions.ValidateAll() if the designated constraints
// aren't met.
type ServiceOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceOptionsMultiError) AllErrors() []error { return m }

// ServiceOptionsValidationError is the validation error returned by
// ServiceOptions.Validate if the designated constraints aren't met.
type ServiceOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceOptionsValidationError) ErrorName() string { return "ServiceOptionsValidationError" }

// Error satisfies the builtin error interface
func (e ServiceOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceOptionsValidationError{}

// Validate checks the field values on MethodOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MethodOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MethodOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MethodOptionsMultiError, or
// nil if none found.
func (m *MethodOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *MethodOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deprecated

	// no validation rules for IdempotencyLevel

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MethodOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MethodOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MethodOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MethodOptionsMultiError(errors)
	}

	return nil
}

// MethodOptionsMultiError is an error wrapping multiple validation errors
// returned by MethodOptions.ValidateAll() if the designated constraints
// aren't met.
type MethodOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MethodOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MethodOptionsMultiError) AllErrors() []error { return m }

// MethodOptionsValidationError is the validation error returned by
// MethodOptions.Validate if the designated constraints aren't met.
type MethodOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MethodOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MethodOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MethodOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MethodOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MethodOptionsValidationError) ErrorName() string { return "MethodOptionsValidationError" }

// Error satisfies the builtin error interface
func (e MethodOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMethodOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MethodOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MethodOptionsValidationError{}

// Validate checks the field values on UninterpretedOption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninterpretedOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninterpretedOption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninterpretedOptionMultiError, or nil if none found.
func (m *UninterpretedOption) ValidateAll() error {
	return m.validate(true)
}

func (m *UninterpretedOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetName() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UninterpretedOptionValidationError{
						field:  fmt.Sprintf("Name[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UninterpretedOptionValidationError{
						field:  fmt.Sprintf("Name[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UninterpretedOptionValidationError{
					field:  fmt.Sprintf("Name[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IdentifierValue

	// no validation rules for PositiveIntValue

	// no validation rules for NegativeIntValue

	// no validation rules for DoubleValue

	// no validation rules for StringValue

	// no validation rules for AggregateValue

	if len(errors) > 0 {
		return UninterpretedOptionMultiError(errors)
	}

	return nil
}

// UninterpretedOptionMultiError is an error wrapping multiple validation
// errors returned by UninterpretedOption.ValidateAll() if the designated
// constraints aren't met.
type UninterpretedOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninterpretedOptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninterpretedOptionMultiError) AllErrors() []error { return m }

// UninterpretedOptionValidationError is the validation error returned by
// UninterpretedOption.Validate if the designated constraints aren't met.
type UninterpretedOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninterpretedOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninterpretedOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninterpretedOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninterpretedOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninterpretedOptionValidationError) ErrorName() string {
	return "UninterpretedOptionValidationError"
}

// Error satisfies the builtin error interface
func (e UninterpretedOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninterpretedOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninterpretedOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninterpretedOptionValidationError{}

// Validate checks the field values on SourceCodeInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SourceCodeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SourceCodeInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SourceCodeInfoMultiError,
// or nil if none found.
func (m *SourceCodeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SourceCodeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLocation() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SourceCodeInfoValidationError{
						field:  fmt.Sprintf("Location[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SourceCodeInfoValidationError{
						field:  fmt.Sprintf("Location[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SourceCodeInfoValidationError{
					field:  fmt.Sprintf("Location[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SourceCodeInfoMultiError(errors)
	}

	return nil
}

// SourceCodeInfoMultiError is an error wrapping multiple validation errors
// returned by SourceCodeInfo.ValidateAll() if the designated constraints
// aren't met.
type SourceCodeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourceCodeInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourceCodeInfoMultiError) AllErrors() []error { return m }

// SourceCodeInfoValidationError is the validation error returned by
// SourceCodeInfo.Validate if the designated constraints aren't met.
type SourceCodeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourceCodeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourceCodeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourceCodeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourceCodeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourceCodeInfoValidationError) ErrorName() string { return "SourceCodeInfoValidationError" }

// Error satisfies the builtin error interface
func (e SourceCodeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSourceCodeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourceCodeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourceCodeInfoValidationError{}

// Validate checks the field values on GeneratedCodeInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GeneratedCodeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GeneratedCodeInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GeneratedCodeInfoMultiError, or nil if none found.
func (m *GeneratedCodeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *GeneratedCodeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAnnotation() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GeneratedCodeInfoValidationError{
						field:  fmt.Sprintf("Annotation[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GeneratedCodeInfoValidationError{
						field:  fmt.Sprintf("Annotation[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GeneratedCodeInfoValidationError{
					field:  fmt.Sprintf("Annotation[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GeneratedCodeInfoMultiError(errors)
	}

	return nil
}

// GeneratedCodeInfoMultiError is an error wrapping multiple validation errors
// returned by GeneratedCodeInfo.ValidateAll() if the designated constraints
// aren't met.
type GeneratedCodeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GeneratedCodeInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GeneratedCodeInfoMultiError) AllErrors() []error { return m }

// GeneratedCodeInfoValidationError is the validation error returned by
// GeneratedCodeInfo.Validate if the designated constraints aren't met.
type GeneratedCodeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GeneratedCodeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GeneratedCodeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GeneratedCodeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GeneratedCodeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GeneratedCodeInfoValidationError) ErrorName() string {
	return "GeneratedCodeInfoValidationError"
}

// Error satisfies the builtin error interface
func (e GeneratedCodeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneratedCodeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GeneratedCodeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GeneratedCodeInfoValidationError{}

// Validate checks the field values on DescriptorProto_ExtensionRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DescriptorProto_ExtensionRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DescriptorProto_ExtensionRange with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DescriptorProto_ExtensionRangeMultiError, or nil if none found.
func (m *DescriptorProto_ExtensionRange) ValidateAll() error {
	return m.validate(true)
}

func (m *DescriptorProto_ExtensionRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DescriptorProto_ExtensionRangeValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DescriptorProto_ExtensionRangeValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DescriptorProto_ExtensionRangeValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DescriptorProto_ExtensionRangeMultiError(errors)
	}

	return nil
}

// DescriptorProto_ExtensionRangeMultiError is an error wrapping multiple
// validation errors returned by DescriptorProto_ExtensionRange.ValidateAll()
// if the designated constraints aren't met.
type DescriptorProto_ExtensionRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescriptorProto_ExtensionRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescriptorProto_ExtensionRangeMultiError) AllErrors() []error { return m }

// DescriptorProto_ExtensionRangeValidationError is the validation error
// returned by DescriptorProto_ExtensionRange.Validate if the designated
// constraints aren't met.
type DescriptorProto_ExtensionRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescriptorProto_ExtensionRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescriptorProto_ExtensionRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescriptorProto_ExtensionRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescriptorProto_ExtensionRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescriptorProto_ExtensionRangeValidationError) ErrorName() string {
	return "DescriptorProto_ExtensionRangeValidationError"
}

// Error satisfies the builtin error interface
func (e DescriptorProto_ExtensionRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescriptorProto_ExtensionRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescriptorProto_ExtensionRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescriptorProto_ExtensionRangeValidationError{}

// Validate checks the field values on DescriptorProto_ReservedRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DescriptorProto_ReservedRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DescriptorProto_ReservedRange with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DescriptorProto_ReservedRangeMultiError, or nil if none found.
func (m *DescriptorProto_ReservedRange) ValidateAll() error {
	return m.validate(true)
}

func (m *DescriptorProto_ReservedRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	if len(errors) > 0 {
		return DescriptorProto_ReservedRangeMultiError(errors)
	}

	return nil
}

// DescriptorProto_ReservedRangeMultiError is an error wrapping multiple
// validation errors returned by DescriptorProto_ReservedRange.ValidateAll()
// if the designated constraints aren't met.
type DescriptorProto_ReservedRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescriptorProto_ReservedRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescriptorProto_ReservedRangeMultiError) AllErrors() []error { return m }

// DescriptorProto_ReservedRangeValidationError is the validation error
// returned by DescriptorProto_ReservedRange.Validate if the designated
// constraints aren't met.
type DescriptorProto_ReservedRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescriptorProto_ReservedRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescriptorProto_ReservedRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescriptorProto_ReservedRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescriptorProto_ReservedRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescriptorProto_ReservedRangeValidationError) ErrorName() string {
	return "DescriptorProto_ReservedRangeValidationError"
}

// Error satisfies the builtin error interface
func (e DescriptorProto_ReservedRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescriptorProto_ReservedRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescriptorProto_ReservedRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescriptorProto_ReservedRangeValidationError{}

// Validate checks the field values on EnumDescriptorProto_EnumReservedRange
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *EnumDescriptorProto_EnumReservedRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnumDescriptorProto_EnumReservedRange
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// EnumDescriptorProto_EnumReservedRangeMultiError, or nil if none found.
func (m *EnumDescriptorProto_EnumReservedRange) ValidateAll() error {
	return m.validate(true)
}

func (m *EnumDescriptorProto_EnumReservedRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	if len(errors) > 0 {
		return EnumDescriptorProto_EnumReservedRangeMultiError(errors)
	}

	return nil
}

// EnumDescriptorProto_EnumReservedRangeMultiError is an error wrapping
// multiple validation errors returned by
// EnumDescriptorProto_EnumReservedRange.ValidateAll() if the designated
// constraints aren't met.
type EnumDescriptorProto_EnumReservedRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumDescriptorProto_EnumReservedRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumDescriptorProto_EnumReservedRangeMultiError) AllErrors() []error { return m }

// EnumDescriptorProto_EnumReservedRangeValidationError is the validation error
// returned by EnumDescriptorProto_EnumReservedRange.Validate if the
// designated constraints aren't met.
type EnumDescriptorProto_EnumReservedRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumDescriptorProto_EnumReservedRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumDescriptorProto_EnumReservedRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumDescriptorProto_EnumReservedRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumDescriptorProto_EnumReservedRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumDescriptorProto_EnumReservedRangeValidationError) ErrorName() string {
	return "EnumDescriptorProto_EnumReservedRangeValidationError"
}

// Error satisfies the builtin error interface
func (e EnumDescriptorProto_EnumReservedRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumDescriptorProto_EnumReservedRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumDescriptorProto_EnumReservedRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumDescriptorProto_EnumReservedRangeValidationError{}

// Validate checks the field values on UninterpretedOption_NamePart with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninterpretedOption_NamePart) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninterpretedOption_NamePart with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninterpretedOption_NamePartMultiError, or nil if none found.
func (m *UninterpretedOption_NamePart) ValidateAll() error {
	return m.validate(true)
}

func (m *UninterpretedOption_NamePart) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamePart

	// no validation rules for IsExtension

	if len(errors) > 0 {
		return UninterpretedOption_NamePartMultiError(errors)
	}

	return nil
}

// UninterpretedOption_NamePartMultiError is an error wrapping multiple
// validation errors returned by UninterpretedOption_NamePart.ValidateAll() if
// the designated constraints aren't met.
type UninterpretedOption_NamePartMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninterpretedOption_NamePartMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninterpretedOption_NamePartMultiError) AllErrors() []error { return m }

// UninterpretedOption_NamePartValidationError is the validation error returned
// by UninterpretedOption_NamePart.Validate if the designated constraints
// aren't met.
type UninterpretedOption_NamePartValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninterpretedOption_NamePartValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninterpretedOption_NamePartValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninterpretedOption_NamePartValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninterpretedOption_NamePartValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninterpretedOption_NamePartValidationError) ErrorName() string {
	return "UninterpretedOption_NamePartValidationError"
}

// Error satisfies the builtin error interface
func (e UninterpretedOption_NamePartValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninterpretedOption_NamePart.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninterpretedOption_NamePartValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninterpretedOption_NamePartValidationError{}

// Validate checks the field values on SourceCodeInfo_Location with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SourceCodeInfo_Location) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SourceCodeInfo_Location with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SourceCodeInfo_LocationMultiError, or nil if none found.
func (m *SourceCodeInfo_Location) ValidateAll() error {
	return m.validate(true)
}

func (m *SourceCodeInfo_Location) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeadingComments

	// no validation rules for TrailingComments

	if len(errors) > 0 {
		return SourceCodeInfo_LocationMultiError(errors)
	}

	return nil
}

// SourceCodeInfo_LocationMultiError is an error wrapping multiple validation
// errors returned by SourceCodeInfo_Location.ValidateAll() if the designated
// constraints aren't met.
type SourceCodeInfo_LocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourceCodeInfo_LocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourceCodeInfo_LocationMultiError) AllErrors() []error { return m }

// SourceCodeInfo_LocationValidationError is the validation error returned by
// SourceCodeInfo_Location.Validate if the designated constraints aren't met.
type SourceCodeInfo_LocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourceCodeInfo_LocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourceCodeInfo_LocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourceCodeInfo_LocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourceCodeInfo_LocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourceCodeInfo_LocationValidationError) ErrorName() string {
	return "SourceCodeInfo_LocationValidationError"
}

// Error satisfies the builtin error interface
func (e SourceCodeInfo_LocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSourceCodeInfo_Location.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourceCodeInfo_LocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourceCodeInfo_LocationValidationError{}

// Validate checks the field values on GeneratedCodeInfo_Annotation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GeneratedCodeInfo_Annotation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GeneratedCodeInfo_Annotation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GeneratedCodeInfo_AnnotationMultiError, or nil if none found.
func (m *GeneratedCodeInfo_Annotation) ValidateAll() error {
	return m.validate(true)
}

func (m *GeneratedCodeInfo_Annotation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceFile

	// no validation rules for Begin

	// no validation rules for End

	if len(errors) > 0 {
		return GeneratedCodeInfo_AnnotationMultiError(errors)
	}

	return nil
}

// GeneratedCodeInfo_AnnotationMultiError is an error wrapping multiple
// validation errors returned by GeneratedCodeInfo_Annotation.ValidateAll() if
// the designated constraints aren't met.
type GeneratedCodeInfo_AnnotationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GeneratedCodeInfo_AnnotationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GeneratedCodeInfo_AnnotationMultiError) AllErrors() []error { return m }

// GeneratedCodeInfo_AnnotationValidationError is the validation error returned
// by GeneratedCodeInfo_Annotation.Validate if the designated constraints
// aren't met.
type GeneratedCodeInfo_AnnotationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GeneratedCodeInfo_AnnotationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GeneratedCodeInfo_AnnotationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GeneratedCodeInfo_AnnotationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GeneratedCodeInfo_AnnotationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GeneratedCodeInfo_AnnotationValidationError) ErrorName() string {
	return "GeneratedCodeInfo_AnnotationValidationError"
}

// Error satisfies the builtin error interface
func (e GeneratedCodeInfo_AnnotationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneratedCodeInfo_Annotation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GeneratedCodeInfo_AnnotationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GeneratedCodeInfo_AnnotationValidationError{}
